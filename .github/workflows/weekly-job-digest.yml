name: Weekly Digest Email

on:
  workflow_dispatch: # Manually trigger for testing
  schedule:
    - cron: '0 0 * * 0' # Every Sunday at midnight UTC (adjust as needed)

jobs:
  send-digest-email:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        
      - name: Get token and fetch jobs/consultants
        id: fetch_data
        run: |
          # Step 1: Get the Sharetribe API Token
          TOKEN=$(curl -s -X POST "https://flex-api.sharetribe.com/v1/auth/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=client_credentials&client_id=${{ secrets.SHARETRIBE_CLIENT_ID }}&client_secret=${{ secrets.SHARETRIBE_CLIENT_SECRET }}" \
            | python -c "import sys, json; print(json.load(sys.stdin)['access_token'])")

          echo "Token fetched successfully!"

          # Step 2: Fetch Job Listings
          JOB_LISTINGS=$(curl -s "https://flex-integ-api.sharetribe.com/v1/integration_api/listings/query?listingType=job&limit=50" \
            -H "Authorization: bearer $TOKEN")
          
          # Step 3: Fetch Consultant Profiles
          CONSULTANT_PROFILES=$(curl -s "https://flex-integ-api.sharetribe.com/v1/integration_api/listings/query?listingType=consultant_profile&limit=50" \
            -H "Authorization: bearer $TOKEN")

          echo "Job Listings: $JOB_LISTINGS"
          echo "Consultant Profiles: $CONSULTANT_PROFILES"
          
          # Store the results to use in the next step
          echo "::set-output name=job_listings::$JOB_LISTINGS"
          echo "::set-output name=consultant_profiles::$CONSULTANT_PROFILES"

      - name: Match Jobs to Consultants
        id: match_jobs
        run: |
          # Step 4: Match Jobs to Consultant Profiles
          JOB_LISTINGS="${{ steps.fetch_data.outputs.job_listings }}"
          CONSULTANT_PROFILES="${{ steps.fetch_data.outputs.consultant_profiles }}"

          # For simplicity, we will just use a placeholder matching logic here
          # Replace this with your matching algorithm based on your actual data structure
          MATCHED_CONSULTANTS=$(echo "$CONSULTANT_PROFILES" | jq '.data[] | select(.attributes.role == "desired_role")')  # Adjust role matching logic as needed

          # Example: Get emails of matched consultants
          EMAILS=$(echo "$MATCHED_CONSULTANTS" | jq -r '.relationships.user.data.id' | sort | uniq)
          
          echo "Matched Consultant Emails: $EMAILS"
          echo "::set-output name=emails::$EMAILS"

      - name: Send Emails via SendPulse
        id: send_email
        run: |
          # Step 5: Send emails using SendPulse
          EMAILS="${{ steps.match_jobs.outputs.emails }}"
          
          # Format the emails for SendPulse (adjust as needed)
          EMAILS_JSON="[\"$EMAILS\"]"  # Assume emails are in a simple array, adjust this based on actual format

          curl -X POST "https://api.sendpulse.com/smtp/send" \
            -H "Authorization: Bearer ${{ secrets.SENDPULSE_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{
                  "email": {
                    "to": '$EMAILS_JSON',
                    "subject": "Weekly Job Listings",
                    "text": "Here are the job listings that match your profile."
                  }
                }'
          
          echo "Emails sent to: $EMAILS"
