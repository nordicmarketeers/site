name: Weekly Job Digest

on:
  schedule:
    - cron: "0 9 * * 1"  # 9 AM UTC every Monday
  workflow_dispatch:

jobs:
  digest:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # ────────────────────────────────────────────────
      # 1. Get Sharetribe Integration API token
      # ────────────────────────────────────────────────
      - name: Fetch Sharetribe API Token
        id: get-token
        run: |
          TOKEN=$(curl -s -X POST "https://flex-api.sharetribe.com/v1/auth/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=client_credentials&client_id=${{ secrets.SHARETRIBE_CLIENT_ID }}&client_secret=${{ secrets.SHARETRIBE_CLIENT_SECRET }}" \
            | jq -r '.access_token')

          if [[ -z "$TOKEN" || "$TOKEN" == "null" ]]; then
            echo "Failed to obtain Sharetribe token"
            exit 1
          fi

          echo "SHARETRIBE_TOKEN=$TOKEN" >> $GITHUB_ENV

      # ────────────────────────────────────────────────
      # 2. Fetch all relevant job listings from last 7 days
      # ────────────────────────────────────────────────
      - name: Fetch recent job listings
        run: |
          SINCE=$(date -u -d "7 days ago" '+%Y-%m-%dT00:00:00Z')

          # We'll collect all pages
          curl -s --get "https://flex-integ-api.sharetribe.com/v1/integration_api/listings/query" \
            -H "Authorization: Bearer $SHARETRIBE_TOKEN" \
            --data-urlencode "listingType=consultant_job" \
            --data-urlencode "createdAtStart=$SINCE" \
            --data-urlencode "limit=100" \
            --data-urlencode "include=user" \
            > jobs_page1.json

          # Very basic pagination – improve if you expect >>100 jobs/week
          jq -r '.data | length' jobs_page1.json > /dev/null  # just to fail early if broken

          echo "JOBS_FILE=jobs_page1.json" >> $GITHUB_ENV

      # ────────────────────────────────────────────────
      # 3. Fetch all approved consultant profiles
      #    (also paginated – this version takes only first 100)
      # ────────────────────────────────────────────────
      - name: Fetch approved consultant profiles
        run: |
          curl -s --get "https://flex-integ-api.sharetribe.com/v1/integration_api/listings/query" \
            -H "Authorization: Bearer $SHARETRIBE_TOKEN" \
            --data-urlencode "listingType=consultant_profile" \
            --data-urlencode "publicData.approved=approved" \
            --data-urlencode "limit=100" \
            --data-urlencode "include=user" \
            > consultants.json

          COUNT=$(jq '.data | length' consultants.json)
          echo "Found $COUNT approved consultant profiles"

          if (( COUNT == 0 )); then
            echo "No approved consultants → nothing to do"
            exit 0   # soft exit — no error
          fi

      # ────────────────────────────────────────────────
      # 4. Match jobs ↔ consultants + collect emails
      # ────────────────────────────────────────────────
      - name: Match jobs and collect recipient emails
        id: match-and-emails
        run: |
          # We'll write emails to this file (one per line)
          echo "" > recipients.txt

          # For each job
          jq -c '.data[]' jobs_page1.json | while read -r job; do
            job_id=$(jq -r '.id' <<< "$job")
            job_title=$(jq -r '.attributes.title // "Untitled job"' <<< "$job")

            # Get job roles as array (or empty array)
            mapfile -t job_roles < <(jq -r '.attributes.publicData.role // [] | .[]' <<< "$job" | sort)

            if [[ ${#job_roles[@]} -eq 0 ]]; then
              echo "Job $job_id has no roles → skipping"
              continue
            fi

            echo "Processing job $job_id: ${job_roles[*]}"

            # Look for consultants whose role array contains ANY of the job roles
            while read -r consultant; do
              consultant_id=$(jq -r '.id' <<< "$consultant")
              profile_id=$(jq -r '.attributes.publicData.latestListing // null' <<< "$consultant")

              if [[ "$profile_id" == "null" ]]; then
                continue
              fi

              mapfile -t cons_roles < <(jq -r '.attributes.publicData.role // [] | .[]' <<< "$consultant" | sort)

              # Check for any intersection
              match_found=false
              for r in "${job_roles[@]}"; do
                if [[ " ${cons_roles[*]} " =~ " $r " ]]; then
                  match_found=true
                  break
                fi
              done

              if $match_found; then
                # Get the real user email from the included user (if present)
                # or fall back to separate /users/show call
                email=$(jq -r --arg pid "$profile_id" '
                  (.included // [] | .[] | select(.type=="user" and (.relationships.listings.data // [] | map(.id) | index($pid))) )?.attributes.email // null
                ' consultants.json)

                if [[ "$email" == "null" || -z "$email" ]]; then
                  user_id=$(jq -r --arg pid "$profile_id" '
                    .data[] | select(.id == $pid) | .attributes.user.id // null
                  ' consultants.json)

                  if [[ -n "$user_id" && "$user_id" != "null" ]]; then
                    email=$(curl -s -H "Authorization: Bearer $SHARETRIBE_TOKEN" \
                      "https://flex-integ-api.sharetribe.com/v1/integration_api/users/show?id=$user_id" \
                      | jq -r '.data.attributes.email // null')
                  fi
                fi

                if [[ -n "$email" && "$email" != "null" ]]; then
                  echo "$email|$job_id|$job_title" >> recipients.txt
                  echo "→ Match! $email for job $job_id"
                fi
              fi
            done < <(jq -c '.data[]' consultants.json)
          done

          # Deduplicate emails (one email can match multiple jobs → send once)
          sort -u recipients.txt | cut -d'|' -f1 | sort -u > unique_emails.txt

          echo "RECIPIENTS_FILE=unique_emails.txt" >> $GITHUB_ENV
          echo "Found $(wc -l < unique_emails.txt) unique recipients"

      # ────────────────────────────────────────────────
      # 5. Send emails via SendPulse (or SendGrid / Resend / ...)
      # ────────────────────────────────────────────────
      - name: Send weekly job digest emails
        if: steps.match-and-emails.outputs.RECIPIENTS_FILE != ''
        env:
          RECIPIENTS: ${{ steps.match-and-emails.outputs.RECIPIENTS_FILE }}
        run: |
          if [[ ! -s "$RECIPIENTS" ]]; then
            echo "No recipients → skipping email step"
            exit 0
          fi

          if [[ "${{ secrets.TEST_MODE }}" == "true" ]]; then
            echo "TEST MODE — would send to:"
            cat "$RECIPIENTS"
            exit 0
          fi

          # Get SendPulse token
          SP_TOKEN=$(curl -s -X POST "https://api.sendpulse.com/oauth/access_token" \
            -H "Content-Type: application/json" \
            -d '{
              "grant_type": "client_credentials",
              "client_id": "${{ secrets.SENDPULSE_CLIENT_ID }}",
              "client_secret": "${{ secrets.SENDPULSE_CLIENT_SECRET }}"
            }' | jq -r '.access_token')

          if [[ -z "$SP_TOKEN" || "$SP_TOKEN" == "null" ]]; then
            echo "Failed to get SendPulse token"
            exit 1
          fi

          # For simplicity we send one email per recipient (no batch)
          # In production → use SendPulse campaign / batch send
          while read -r email; do
            curl -s -X POST "https://api.sendpulse.com/smtp/emails" \
              -H "Authorization: Bearer $SP_TOKEN" \
              -H "Content-Type: application/json" \
              -d '{
                "email": {
                  "subject": "Weekly Job Opportunities Matching Your Profile",
                  "html": "<h2>New jobs this week</h2><p>We found job listing(s) that match your roles.</p><p>Check them out on the platform!</p><p><a href=\"https://your-platform.com\">View jobs →</a></p>",
                  "from": {
                    "name": "Your Platform Jobs",
                    "email": "${{ secrets.FROM_EMAIL }}"
                  },
                  "to": [{"email": "'"$email"'"}]
                }
              }'
            echo "Sent to $email"
            sleep 0.8   # very basic rate limit avoidance
          done < "$RECIPIENTS"

          echo "Email sending completed."
