name: Weekly Job Digest

on:
  schedule:
    - cron: "0 9 * * 1"  # 9 AM UTC every Monday
  workflow_dispatch:

jobs:
  digest:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # 1. Get Sharetribe Integration API token
      - name: Fetch Sharetribe API Token
        id: get-token
        run: |
          TOKEN=$(curl -s -X POST "https://flex-api.sharetribe.com/v1/auth/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=client_credentials&client_id=${{ secrets.SHARETRIBE_CLIENT_ID }}&client_secret=${{ secrets.SHARETRIBE_CLIENT_SECRET }}" \
            | jq -r '.access_token')

          if [[ -z "$TOKEN" || "$TOKEN" == "null" ]]; then
            echo "Failed to obtain Sharetribe token"
            exit 1
          fi

          echo "SHARETRIBE_TOKEN=$TOKEN" >> $GITHUB_ENV

      # 2. Fetch recent job listings (last 7 days)
      - name: Fetch recent job listings
        run: |
          SINCE=$(date -u -d "7 days ago" '+%Y-%m-%dT00:00:00Z')

          curl -s --get "https://flex-integ-api.sharetribe.com/v1/integration_api/listings/query" \
            -H "Authorization: Bearer $SHARETRIBE_TOKEN" \
            --data-urlencode "listingType=consultant_job" \
            --data-urlencode "createdAtStart=$SINCE" \
            --data-urlencode "limit=100" \
            --data-urlencode "include=user" \
            > jobs_page1.json

          COUNT=$(jq '.data | length' jobs_page1.json || echo 0)
          echo "Found $COUNT recent job listings"

      # 3. Fetch all approved consultant profiles
      - name: Fetch approved consultant profiles
        run: |
          curl -s --get "https://flex-integ-api.sharetribe.com/v1/integration_api/listings/query" \
            -H "Authorization: Bearer $SHARETRIBE_TOKEN" \
            --data-urlencode "listingType=consultant_profile" \
            --data-urlencode "publicData.approved=approved" \
            --data-urlencode "limit=100" \
            --data-urlencode "include=user" \
            > consultants.json

          COUNT=$(jq '.data | length' consultants.json || echo 0)
          echo "Found $COUNT approved consultant profiles"

          if (( COUNT == 0 )); then
            echo "No approved consultants → nothing to do"
            exit 0
          fi

      # 4. Match jobs to consultants + prepare per-recipient job lists
      - name: Match jobs and prepare digest data
        id: match-and-prepare
        run: |
          echo "" > matches.csv

          jq -c '.data[]' jobs_page1.json | while read -r job; do
            job_id=$(jq -r '.id' <<< "$job")
            job_title=$(jq -r '.attributes.title // "Job opportunity"' <<< "$job")
            job_url="https://your-platform.com/listing/${job_id}"   # ← CHANGE THIS TO YOUR REAL URL PATTERN

            mapfile -t job_roles < <(jq -r '.attributes.publicData.role // [] | .[]' <<< "$job" | sort)

            if [[ ${#job_roles[@]} -eq 0 ]]; then
              echo "Skipping job $job_id — no roles"
              continue
            fi

            echo "Processing job $job_id: ${job_roles[*]}"

            jq -c '.data[]' consultants.json | while read -r consultant; do
              profile_id=$(jq -r '.attributes.publicData.latestListing // null' <<< "$consultant")
              if [[ "$profile_id" == "null" ]]; then 
                echo "DEBUG: Skipping consultant — no latestListing"
                continue; 
              fi

              mapfile -t cons_roles < <(jq -r '.attributes.publicData.role // [] | .[]' <<< "$consultant" | sort)

              # ─────────────── DEBUG OUTPUT ───────────────
              echo "DEBUG: Consultant profile $profile_id → roles: ${cons_roles[*]:-EMPTY}"
              echo "DEBUG: Comparing to job roles: ${job_roles[*]}"

              match_found=false
              for r in "${job_roles[@]}"; do
                if [[ " ${cons_roles[*]} " == *" $r "* ]]; then
                  match_found=true
                  break
                fi
              done

              if $match_found; then
                echo "DEBUG: MATCH FOUND for consultant $profile_id on job $job_id"

                # Try to get email from included user data
                email=$(jq -r --arg pid "$profile_id" '
                  (.included // [] | .[] | select(.type=="user") 
                  | select(.relationships.listings.data // [] | map(.id) | index($pid)) 
                  | .attributes.email // null
                ' consultants.json)

                echo "DEBUG: Email from included query: ${email:-(not found in included)}"

                if [[ -z "$email" || "$email" == "null" ]]; then
                  echo "DEBUG: Falling back to direct API calls for profile $profile_id"
                  
                  user_resp=$(curl -s -H "Authorization: Bearer $SHARETRIBE_TOKEN" \
                    "https://flex-integ-api.sharetribe.com/v1/integration_api/listings/show?id=$profile_id")

                  user_id=$(echo "$user_resp" | jq -r '.data.attributes.author.id // null')

                  echo "DEBUG: Fetched user ID from listing: ${user_id:-(none)}"

                  if [[ -n "$user_id" && "$user_id" != "null" ]]; then
                    email=$(curl -s -H "Authorization: Bearer $SHARETRIBE_TOKEN" \
                      "https://flex-integ-api.sharetribe.com/v1/integration_api/users/show?id=$user_id" \
                      | jq -r '.data.attributes.email // null')

                    echo "DEBUG: Email from users/show: ${email:-(not found)}"
                  fi
                fi

                if [[ -n "$email" && "$email" != "null" ]]; then
                  echo "$email|$job_id|$job_title|$job_url" >> matches.csv
                  echo "MATCH RECORDED → $email for $job_title"
                else
                  echo "DEBUG: No valid email found — skipping record"
                fi
              else
                echo "DEBUG: No match for consultant $profile_id"
              fi
            done
          done

          # Aggregate jobs per email
          awk -F'|' '
            {
              if ($1 != "") {
                jobs[$1] = jobs[$1] ? jobs[$1] ", <li><a href=\"" $4 "\">" $3 "</a></li>" : "<li><a href=\"" $4 "\">" $3 "</a></li>"
              }
            }
            END {
              for (e in jobs) print e "|" jobs[e]
            }' matches.csv > aggregated.csv

          # Unique emails
          cut -d'|' -f1 aggregated.csv | sort -u > unique_emails.txt

          NUM=$(wc -l < unique_emails.txt || echo 0)

          # Set step outputs
          echo "recipients_file=unique_emails.txt" >> $GITHUB_OUTPUT
          echo "aggregated_file=aggregated.csv" >> $GITHUB_OUTPUT
          echo "recipient_count=$NUM" >> $GITHUB_OUTPUT

          echo "Found $NUM unique recipients"

          # Final debug
          echo "Contents of matches.csv:"
          cat matches.csv || echo "(empty)"
          echo "Contents of aggregated.csv:"
          cat aggregated.csv || echo "(empty)"

      # 5. Send emails or show preview in test mode
      - name: Send weekly job digest emails
        if: always()
        env:
          RECIPIENTS_FILE: ${{ steps.match-and-prepare.outputs.recipients_file }}
          AGGREGATED_FILE: ${{ steps.match-and-prepare.outputs.aggregated_file }}
          RECIPIENT_COUNT: ${{ steps.match-and-prepare.outputs.recipient_count }}
        run: |
          echo "Step outputs received:"
          echo "recipients_file  = $RECIPIENTS_FILE"
          echo "aggregated_file  = $AGGREGATED_FILE"
          echo "recipient_count  = $RECIPIENT_COUNT"

          if [[ -z "$RECIPIENTS_FILE" || ! -f "$RECIPIENTS_FILE" || ! -s "$RECIPIENTS_FILE" ]]; then
            echo "No recipients file or file is empty — nothing to send"
            ls -la *.csv *.txt || true
            cat matches.csv || echo "(matches.csv missing)"
            cat aggregated.csv || echo "(aggregated.csv missing)"
            exit 0
          fi

          echo "Recipients:"
          cat "$RECIPIENTS_FILE"

          if [[ "${{ secrets.TEST_MODE }}" == "true" ]]; then
            echo ""
            echo "TEST MODE — preview of emails:"

            while IFS='|' read -r email jobs_html; do
              echo "----------------------------------------"
              echo "To: $email"
              echo "Subject: Weekly Job Opportunities Matching Your Profile"
              echo ""
              echo "HTML preview:"
              echo "<h2>New matching jobs this week</h2>"
              echo "<p>We found the following jobs that match your roles:</p>"
              echo "<ul>$jobs_html</ul>"
              echo "<p><a href=\"https://your-platform.com/search/jobs\">View all jobs →</a></p>"
              echo ""
            done < "$AGGREGATED_FILE"

            exit 0
          fi

          # Real sending
          SP_TOKEN=$(curl -s -X POST "https://api.sendpulse.com/oauth/access_token" \
            -H "Content-Type: application/json" \
            -d '{
              "grant_type": "client_credentials",
              "client_id": "${{ secrets.SENDPULSE_CLIENT_ID }}",
              "client_secret": "${{ secrets.SENDPULSE_CLIENT_SECRET }}"
            }' | jq -r '.access_token // empty')

          if [[ -z "$SP_TOKEN" ]]; then
            echo "Failed to get SendPulse token"
            exit 1
          fi

          while IFS='|' read -r email jobs_html; do
            curl -s -X POST "https://api.sendpulse.com/smtp/emails" \
              -H "Authorization: Bearer $SP_TOKEN" \
              -H "Content-Type: application/json" \
              -d '{
                "email": {
                  "subject": "Weekly Job Opportunities Matching Your Profile",
                  "html": "<h2>New matching jobs this week</h2><p>We found the following jobs that match your roles:</p><ul>"'"${jobs_html}"'"</ul><p><a href=\"https://your-platform.com/search/jobs\">Browse all opportunities →</a></p><p>Best regards,<br>Your Platform Team</p>",
                  "from": { "name": "Your Platform Jobs", "email": "${{ secrets.FROM_EMAIL }}" },
                  "to": [{ "email": "'"$email"'" }]
                }
              }'
            echo "Sent to $email"
            sleep 1.2
          done < "$AGGREGATED_FILE"

          echo "Email sending completed."
